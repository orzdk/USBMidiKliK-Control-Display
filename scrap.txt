void processRouteDialBuffer()
{
  Serial.println("processRouteDialBuffer");

    uint8_t db0 = (uint8_t)(dialBuffer[0]-'0');
    uint8_t db1 = (uint8_t)(dialBuffer[1]-'0');
    uint8_t src_id = (db0 * 10) + db1; 

  currentBmt ^= 1UL << src_id-1;
  
  Serial.println("src_id");
  Serial.println(src_id);
    
  Serial.print("currentBmt");
  Serial.println(currentBmt, BIN);
 
  uint8_t numChannels = countSetBits(currentBmt);
  uint8_t sysex[numChannels];
  uint8_t sz = numChannels + 10;
  uint8_t datapos = 9;

  Serial.print("numChannels");
  Serial.println(numChannels);
 
  Serial.print("sz");
  Serial.println(sz);
  
  uint8_t sysexConfig[9] = {0xF0, 0x77, 0x77, 0x78, 0x0F, D_routeOrFilter, D_cableOrJack, D_port, D_cableOrJack_t};
  uint8_t sysexEnd[1] = { 0xF7 };
  uint8_t sysexComplete[sz];
 
  memcpy(sysexComplete,sysexConfig,9*sizeof(uint8_t));
  memcpy(sysexComplete+sz-1,sysexEnd,sizeof(byte));
  sysexComplete[sz-1] = 0xF7;
  
  for (ii=0;ii<=15;ii++){
    Serial.println(1UL << ii, BIN);
    Serial.println(currentBmt, BIN);
    if (currentBmt & (1UL << ii)){
      Serial.println("ping");
      Serial.println(ii);
      sysexComplete[datapos++] = ii;
    }
  }

  Serial.print("sysexComplete[sz-1]");
  Serial.println(sysexComplete[sz-1], HEX);


     
     for (int i = 0; i<sz; i++){
        Serial.print(i);Serial.print(" : ");
        if (i>=0 && i<5) Serial.print("Header ");
        if (i==5) Serial.print("RouteOrFilter ");
        if (i==6) Serial.print("CableOrJack ");
        if (i==7) Serial.print("Port ");
        if (i==8) Serial.print("CableOrJackT ");
        if (i>8) Serial.print("DATA ");
        if ( sysexComplete[i] < 0x10 ) Serial.print("0");
        Serial.println(sysexComplete[i], HEX);
     }
     
  //dumpBufferToSerial((uint8_t*)sysexConfig,sz);
  
  nums = 0;
  dialCableOrJack = 'R';
  dialBufferPos = 0;
  memset(dialBuffer, 0, sizeof(dialBuffer));
  
}




  void processKeypad()
{
  displayWrite(&display, &keyPress, 0, 0, 1);

  switch (keyPress)
  {
    case NO_KEY:
      break;

    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
      nums++;
      dialBuffer[dialBufferPos++] = keyPress;
      if (nums == 3 || (nums > 0 && tags == 0)) resetBuffers();
      if (tags == 2 && nums == 2) processDialBuffer();
      break;

    case '#': case '*':
      if (lastKeyPress == '#' || lastKeyPress == '*') {
        resetBuffers();
      } else {
        tags++; nums = 0;
        dialBuffer[dialBufferPos++] = keyPress;
      }
      break;

  }

  lastKeyPress = keyPress;

}



   if (boxMode == 0){             //USBMidiKlik Remote 
    
   } else if (boxMode == 1){      //SysEx Bank
    
   } 
char*  boxModeMenu_ITEMS1[] = {"USBMidiKlik","Sysex Bank"}; 
   //void processDialBuffer()
//{
//   uint16_t cableMask = 0x0; /*Get from MidiKlik */
//   uint16_t jackMask = 0x0; /*Get from MidiKlik */
//   
//   uint8_t sysex[14] = {0xF0, 0x77, 0x77, 0x78, 0x0F, 0x01,};
//   
//   int styp = dialBuffer[0] == '#' ? 0 : 1;
//   int ttyp = dialBuffer[3] == '#' ? 0 : 1;
//   
//   int src_id = ((int)(dialBuffer[1]) * 10) + (int)(dialBuffer[2]); 
//   int tgt_id = ((int)(dialBuffer[4]) * 10) + (int)(dialBuffer[4]); 
//  
//   cableMask ^= !ttyp * (1UL << tgt_id);
//   jackMask ^= ttyp * (1UL << tgt_id);
//   
//   sysex[6] = 0xFF & styp;
//   sysex[7] = 0xFF & src_id;
//   sysex[8] = 0x0F;
//   sysex[9] = cableMask >> 8;
//   sysex[10] = cableMask & 0xFF;
//   sysex[11] = jackMask >> 8;
//   sysex[12] = jackMask & 0xFF;
//   sysex[13] = 0xF7;
//
//   int i;
//   for (i=0; i<sizeof(sysex)/sizeof(sysex[0]);i++){
//      Serial.print(sysex[i], HEX);
//      Serial.print(" ");
//   }
//   Serial.println(".......................");
//   
//   SendSysexToSerialAndUSB(sysex, 14);
//   resetBuffers();
//}
     displayWrite(&display, ">> ",0,10,0);
     displayWrite(&display,menus[boxModeMLevel].members[boxMode],12,10,0);

     if (boxMode == 0)
     {
        digitalWrite(LED_RED, HIGH);
        digitalWrite(LED_GREEN, HIGH);
     } 
     else if (boxMode == 1)
     {
        digitalWrite(LED_RED, HIGH);
        digitalWrite(LED_GREEN, LOW);  
     } 
     else if (boxMode == 2)
     {
        digitalWrite(LED_RED, LOW);
        digitalWrite(LED_GREEN,HIGH );   
           
     } else if (boxMode == 3)
     {
        digitalWrite(LED_RED, LOW);
        digitalWrite(LED_GREEN, LOW);     
     }


#include "RingBuffer.h";
//#define B_RING_BUFFER_PACKET_SIZE  16*sizeof(midiPacket_t)
//RingBuffer<uint8_t,B_RING_BUFFER_PACKET_SIZE> serialRingBuffer;
//serialRingBuffer.write((uint8_t *)&pk,sizeof(midiPacket_t));
//serialRingBuffer.available();
//serialRingBuffer.readBytes(pk.packet,sizeof(midiPacket_t));


const char *a[2];
a[0] = "blah";
a[1] = "hmm";


char a[2][14];
strcpy(a[0], "blah");
strcpy(a[1], "hmm");


Serial.print("PCK ");
Serial.println(pk.i,HEX);

display2.setTextColor(WHITE);
display2.setCursor(tlx,tly);
display2.println(pk.i,HEX);
display2.display();


      Serial.println("");     

      display2.clearDisplay();
      display2.setTextSize(1);
      display2.setTextColor(WHITE);
     
      for (int i = 0; i < serialBufferIDX; i++) {
         display2.setCursor(i*6,0);
         display2.println((char)serialBuffer[i]);
      }
      display2.display();



void SendSysexToSerialAndUSB(const uint8_t *data, size_t size)
{
    if (data == NULL || size == 0) return;

    size_t midiDataSize = (size+2)/3*4;
    uint8_t midiData[midiDataSize];
    const uint8_t *d = data;
    uint8_t *p = midiData;
    
    size_t bytesRemaining = size;

    while (bytesRemaining > 0) {
      switch (bytesRemaining) {
      case 1:
          *p++ = 5;   // SysEx ends with following single byte
          *p++ = *d;
          *p++ = 0;
          *p = 0;
          bytesRemaining = 0;
          break;
      case 2:
          *p++ = 6;   // SysEx ends with following two bytes
          *p++ = *d++;
          *p++ = *d;
          *p = 0;
          bytesRemaining = 0;
          break;
      case 3:
          *p++ = 7;   // SysEx ends with following three bytes
          *p++ = *d++;
          *p++ = *d++;
          *p = *d;
          bytesRemaining = 0;
          break;
      default:
          *p++ = 4;   // SysEx starts or continues
          *p++ = *d++;
          *p++ = *d++;
          *p++ = *d++;
          bytesRemaining -= 3;
          break;
      }
    }

    for (int i=0;i<midiDataSize;i+=4){
      uint32_t package = (midiData[i+3] << 24) | (midiData[i+2] << 16)| (midiData[i+1] << 8) | (midiData[i] | (1 << 4));
      midiPacket_t lpk = { .i = package };
      
      MidiUSB.writePacket(&(lpk.i));
      
    }
}

LCD STUFF



//#include <LiquidCrystal.h> 
//const int rs = PB11, en = PB10, d4 = PB0, d5 = PB1, d6 = PC13, d7 = PC14;
//LiquidCrystal lcd(rs, en, d4, d5, d6, d7); 
//  lcd.begin(16, 2); 
//  lcd.setCursor(0, 0); 
//  lcd.print("Ready")

//    lcd.setCursor(0, 0); 
//    lcd.print("msgLen");  
//    lcd.setCursor(0, 1); 
//    lcd.print(msgLen);
//    lcd.setCursor(3, 1); 
//    lcd.print(j);
//    
//    lcd.setCursor(5, 1); 
//    lcd.print(pk->packet[0], HEX);
//    
//    lcd.setCursor(8, 1); 
//    lcd.print(pk->packet[1], HEX);
//    
//    lcd.setCursor(11, 1); 
//    lcd.print(pk->packet[2], HEX);
//
//    lcd.setCursor(14, 1); 
//    lcd.print(pk->packet[3], HEX);

fra erial wwrote Ã¥packet

    Serial.print(" j:");
    Serial.println(j,HEX);

    Serial.print(" msgLen:");
    Serial.println(msgLen,HEX);

    Serial.print(" packet:");
    Serial.print(pk->packet[0],HEX);
    
    Serial.print(" packet:");
    Serial.print(pk->packet[1],HEX);

    Serial.print(" packet:");
    Serial.print(pk->packet[2],HEX);

    Serial.print(" packet:");
    Serial.print(pk->packet[3],HEX);

    Serial.println("--------------------------------------------------------");
    






// Send a midi msg to serial MIDI. 0 is Serial1.
static void SendMidiMsgToSerial(uint8_t const *msg, uint8_t serialNo) {

  if (serialNo >= SERIAL_INTERFACE_MAX ) return;

  uint8_t msgLen = midiXparser::getMidiStatusMsgLen(msg[0]);

  if ( msgLen > 0 ) {
    if (msgLen >= 1 ) serialHw[serialNo]->write(msg[0]);
    if (msgLen >= 2 ) serialHw[serialNo]->write(msg[1]);
    if (msgLen >= 3 ) serialHw[serialNo]->write(msg[2]);
  }
}

    /* send all routes */
    //      Wire.beginTransmission(8);
    //      Wire.write(sMsg);
    //      Wire.endTransmission();    
    //      delay(500);


/**/
/* 
   This is the control & display slave for UsbMidiKliK 
   Unit processes keypad codes and sends sysex to midiklik
*/

#include <LiquidCrystal.h> 
#include<Wire_slave.h> 
#include "Keypad.h"

const byte ROWS = 4;
const byte COLS = 4;

char hexaKeys[ROWS][COLS] = {
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'*','0','#','D'}
};

byte rowPins[ROWS] = {3, 2, 1, 0};
byte colPins[COLS] = {7, 6, 5, 4};

Keypad customKeypad = Keypad( makeKeymap(hexaKeys), rowPins, colPins, ROWS, COLS); 

const int rs = PB11, en = PB10, d4 = PB0, d5 = PB1, d6 = PC13, d7 = PC14;
LiquidCrystal messagelcd(rs, en, d4, d5, d6, d7); 

char keyBuffer[6]; 
int keyBufferPos = 0;

char keyPress;
char lastKeyPress;

int tags = 0;
int nums = 0;

char sysex[14] = {0xF0, 0x77, 0x77, 0x78, 0x0F, 0x01,};
char sMsg;

bool sysexReady = false;

void setup() 
{
  Wire.begin(8);  
  Wire.onReceive(onReceiveEvent);              
  Wire.onRequest(onRequestEvent);             
  
  Serial.begin(9600);
  messagelcd.begin(16, 2);  

  resetBuffer();
}

void onRequestEvent()  /* USBMidiKlik request keypad data */                          
{
  Serial.print("Request from master");
  if (sysexReady == true){
    Serial.print("Writing sysex");
    Wire.write(sysex);                     
    sysexReady = false;
  }
}

void onReceiveEvent(int howMany) {  /* Control surface receives display back from USBMidiKlik */ 
  
  Serial.print("Event from master"); 
  
  while (1 < Wire.available()) { 
    sMsg += Wire.read(); 
  }
  Serial.print(sMsg);         
  messagelcd.setCursor(0, 1); 
  messagelcd.print(sMsg);
}

void resetBuffer()
{
  tags=0;
  nums=0;
  keyBufferPos = 0;
  memset(keyBuffer, 0, sizeof(keyBuffer));
}

void p(char X) {
   if (X < 16) {Serial.print("0");}
   Serial.print(X, HEX);
   Serial.print(" ");
}

void processBuffer()
{
  messagelcd.setCursor(0, 1); 
  messagelcd.print("Processing");
          
  uint16_t cableMask = 0xFFFF; /*Get from MidiKlik */
  uint16_t jackMask = 0xFFFF; /*Get from MidiKlik */

  int src_cableserial_id = ((keyBuffer[1] - '0') * 10) + (keyBuffer[2] - '0'); 
  int tgt_cableserial_id = ((keyBuffer[4] - '0') * 10) + (keyBuffer[5] - '0'); 
  
  cableMask ^= !(keyBuffer[3] - '0') * (1UL << tgt_cableserial_id);
  jackMask ^= (keyBuffer[3] - '0') * (1UL << tgt_cableserial_id);
 
  sysex[6] = 0xFF & (keyBuffer[0] - '0');
  sysex[7] = 0xFF & src_cableserial_id;
  sysex[8] = 0xFF;
  sysex[9] = cableMask >> 8;
  sysex[10] = cableMask & 0xFF;
  sysex[11] = jackMask >> 8;
  sysex[12] = jackMask & 0xFF;
  sysex[13] = 0xF7;
  
  sysexReady = true;
  
  for(int a=0;a<sizeof(sysex)/sizeof(sysex[0]);a++){
    p(sysex[a]);
  }

}

void loop() 
{
   delay(100);
   Serial.println(sysexReady);
   keyPress = customKeypad.getKey();
   
    if (keyPress) {

     switch (keyPress)
     {
        case NO_KEY:
          break;
        
        case '0': case '1': case '2': case '3': case '4':
        case '5': case '6': case '7': case '8': case '9':
          keyBuffer[keyBufferPos++] = keyPress;
          nums++;
          messagelcd.setCursor(0, 0); 
          messagelcd.print(keyBuffer);

          messagelcd.setCursor(10, 0); 
          messagelcd.print(tags);

          messagelcd.setCursor(13, 0); 
          messagelcd.print(nums);
          
          if (tags == 2 && nums == 2) processBuffer();
          break;

        case '#':
          if (lastKeyPress == '#' || lastKeyPress == '*') {
              resetBuffer();
              messagelcd.setCursor(0, 0); 
              messagelcd.print("Error");
          } else {
             tags++;nums=0;
             keyBuffer[keyBufferPos++] = '0';
             messagelcd.setCursor(0, 0); 
             messagelcd.print(keyBuffer);
                       messagelcd.setCursor(10, 0); 
          messagelcd.print(tags);

          messagelcd.setCursor(13, 0); 
          messagelcd.print(nums);
          }
          break;

        case '*':
          if (lastKeyPress == '#' || lastKeyPress == '*') {
              resetBuffer();
              messagelcd.setCursor(0, 0); 
              messagelcd.print("Error");
          } else {
            tags++;nums=0;
            keyBuffer[keyBufferPos++] = '1';
            messagelcd.setCursor(0, 0); 
            messagelcd.print(keyBuffer);
                      messagelcd.setCursor(10, 0); 
          messagelcd.print(tags);

          messagelcd.setCursor(13, 0); 
          messagelcd.print(nums);
          }
          
     }

     lastKeyPress = keyPress;
    }

}



/**/
  Serial.print("cablemask");
  Serial.print(cableMask,HEX);
  Serial.print("jackmask");
  Serial.print(jackMask,HEX);
  Serial.print("tgt_cableserial_id");
  Serial.print(tgt_cableserial_id);

    /* Current Mask 1111 00000000 00000000 00000000 00000000
   * We get 0 1 12 6
   * We want F0 77 77 78 01 | 00 | 00 | 00 | 0000 | 0000 | 0000 | 0000 
   *         header         | sr | id | fms| cablebmak   | jackmask 
   */
  
    Serial.println("--togglemasks cable jack--------------");
    Serial.println(cableToggleMask);
  Serial.println(jackToggleMask);


  Serial.println("----------------");
    Serial.println(mask);
  Serial.println(currentCables);
  Serial.println(currentJacks);
  Serial.println("----------------");
  Serial.println(keyBuffer[0]);
  Serial.println(keyBuffer[1]);
  Serial.println(keyBuffer[2]);
  Serial.println(keyBuffer[3]);
  Serial.println(keyBuffer[4]);
  Serial.println(keyBuffer[5]);
  Serial.println(keyBuffer[6]);
  Serial.println(keyBuffer[7]);
  Serial.println("----------------");  
  Serial.println(s_cableserial);
  Serial.println(s_cableserial_id);
  Serial.println(t_cableserial);
  Serial.println(t_cableserial_id);
 

   uint8_t currentMapping;
   char sysexString[];
   char d1;

   unsigned char sysex[13] = {0xF0, 0x77, 0x77, 0x78, 0x0F, 0x01,};
   sysex[6] = keyBuffer[1];
   sysex[7] = keyBuffer[2];

   uint16_t cable = 0xFFFF & keyBuffer[1];
     
  /*if (keyBuffer[0] != "#" || keyBuffer[7] != "*" || (sizeof(keyBuffer)/sizeof(keyBuffer[0])) != "8" ){
    
    messagelcd.setCursor(0, 0); 
    messagelcd.print("ERROR");
    resetBuffer();

    for (int x = 0; x < sizeof(integerArray) / sizeof(integerArray[0]); x++)
    {
      integerArray[x] = 0;
    }

    
  } 
  else {*/

    int sourceType = keyBuffer[1];
    int sourceId = keyBuffer[2];
    int toCableId = keyBuffer[3];
    int toJackId = keyBuffer[4];
    
    messagelcd.setCursor(0, 0); 
    messagelcd.print(keyBuffer);
    
   /*}*/

  for (int x = 0; x < sizeof(keyBuffer) / sizeof(keyBuffer[0]); x++)
  {
    if (strcmp(keyBuffer[x], "#") == 0){
      if (
      hexBuf[hexBufPos++] = 
      cmd = 1;
    }
    else {
      if (cmd == 1){
        intToHexBuf[intToHexBufPos++] = keyBuffer[x];
      }
    }
    
  }

  int intToHexBuf[2];
  int intToHexBufPos = 0;
  
  int hexBuf[4];
  int hexBufPos = 0;


  
  for (int x = 0; x < sizeof(sysex) / sizeof(sysex[0]); x++){
    Serial.print(x); 
    Serial.print(":"); 
    Serial.println(sysex[x], HEX);  
  }


void p(char X) {
   if (X < 16) {Serial.print("0");}
   Serial.print(X, HEX);
   Serial.print(" ");
}

/* Setup MASTER */
void setup() {
    Wire.begin();   
    //attachInterrupt(digitalPinToInterrupt(interruptPin), blink1, FALL); 
    Serial.begin(9600);
    pinMode(interruptPin, INPUT);
}

//void blink1() {
//  state = !state; 
//}




uint8_t data_to_sysex(uint8_t *data, uint8_t *sysex, uint8_t len) 
{
  uint8_t retlen = 0;
  uint8_t cnt;
  uint8_t cnt7 = 0;

  sysex[0] = 0;
  for (cnt = 0; cnt < len; cnt++) {
    uint8_t c = data[cnt] & 0x7F;
    uint8_t msb = data[cnt] >> 7;
    sysex[0] |= msb << cnt7;
    sysex[1 + cnt7] = c;

    if (cnt7++ == 6) {
      sysex += 8;
      retlen += 8;
      sysex[0] = 0;
      cnt7 = 0;
    }
  }
  return retlen + cnt7 + (cnt7 != 0 ? 1 : 0);
}

uint8_t sysex_to_data(uint8_t *sysex, uint8_t *data, uint8_t len) 
{
  uint8_t cnt;
  uint8_t cnt2 = 0;
  uint8_t bits = 0;
  for (cnt = 0; cnt < len; cnt++) {
    if ((cnt % 8) == 0) {
      bits = sysex[cnt];
    } else {
      data[cnt2++] = sysex[cnt] | ((bits & 1) << 7);
      bits >>= 1;
    }
  }
  return cnt2;
}
